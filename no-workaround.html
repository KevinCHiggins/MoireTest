<!DOCTYPE HTML>
<head>
	<meta charset="utf-8">
	<title>Hard-pixel SVG</title>
	<link href="https://fonts.googleapis.com/css?family=Aleo:300&display=swap" rel="stylesheet" />
	<link rel="stylesheet" href="css/styles.css" type="text/css" />
	<style></style>
</head>
<body>
	<header>
		<h1>Hard-pixel SVG: Masked Moir√©</h1>
		<h3>by Kevin Higgins</h3>
	</header>
	<main class="main-block">
		<div class="panels">
			<div class="svg-panel"><svg xmlns="http://www.w3.org/2000/svg"></svg>
			</div>
			<div class="control-panel">
				<h4>Edit selected shape</h4><label for="dash-array-field">Stroke dash array</label>
				<input type="text" value="1,1" id="dash-array-field" /><label for="stroke-width-field">Stroke width</label><input type="number" placeholder="1" max="500" min="0" value="40" id="stroke-width-field" />
				<hr />

				<input class="moire-button" type="button" value="Next path" id="reset-button" />

				<input class="moire-button" type="button" value="Switch shape-rendering" id="render-button" />
				<input class="moire-button" type="button" value="Download" id="dl-button" />
				<input class="moire-button" type="button" value="Move up" id="move-up-button" />
				<input class="moire-button" type="button" value="Move down" id="move-down-button" />
				<label for="masked-button">Masked</label>
				<input class="moire-radio-button" type="radio" name="mask-options" value="masked" id="masked-button" />
				<label for="unmasked-button">Unmasked</label>

				<input class="moire-radio-button" type="radio" name="mask-options" value="unmasked"id="unmasked-button" />
				<label for="sent-to-mask-button">Sent to mask</label>
				<input class="moire-radio-button" type="radio" name="mask-options" value="sent" id="sent-to-mask-button" />

				<input type="color" value="#ffffff" id="col-button" />

				<a id="concealed-dl-link">Download SVG</a> <!--technique from boomcreeper11 on SO-->
			</div>
			
		</div>
	</main>
	<script>

		document.querySelector('#render-button').addEventListener("click", switchRender);
		document.querySelector('#move-up-button').addEventListener("click", function() {move(1); });
		document.querySelector('#move-down-button').addEventListener("click", function() {move(-1); });
		document.querySelector('#masked-button').addEventListener("click", function() {masking(this.value)});
		document.querySelector('#unmasked-button').addEventListener("click", function() {masking(this.value)});
		document.querySelector('#sent-to-mask-button').addEventListener("click", function() {masking(this.value)})
		document.querySelector('#reset-button').addEventListener("click", switchEl);
		document.querySelector('#dl-button').addEventListener("click", downloadSvg);
		document.querySelector('#concealed-dl-link').addEventListener("click", function() { this.style.display = "none"; })
		document.querySelector('#dash-array-field').addEventListener("input", function() { changeDashArray(this.value) });
		document.querySelector('#stroke-width-field').addEventListener("change", function() { changeStrokeWidth(this.value) });
		document.querySelector('#col-button').addEventListener("change", function() { changeColour(this.value) });
		var dragged = false;
		var xhttp = new XMLHttpRequest();
		var handleSize = 10;
		var dragUpdates = 0;
		var handles = [];
		var timeLastDragged= new Date();
		var shapes = [];
		var shapeMasking = []; // 2D array, 2 members in each subarray: boolean masked (false means part of mask) and a string, which for now is always = MASK_NAME; empty string, unmasked
		const MASK_NAME = "mask1";
		var selectedHandle = -1;
		var selectedShape = 0; // there'll always be a shapes selected; start with first member of array selected
		var svgObject;
		function masking(value) {
			let maskingOptions = [];
			let shape = shapes[selectedShape];
			console.log(shape);
			let mask = document.getElementById(MASK_NAME); // assuming it's there, but we put it in during loading
			if (value == "sent") {
				maskingOptions[0] = false;
				maskingOptions[1] = MASK_NAME;
				svgObject.removeChild(shape);
				
				if (mask.children != null && mask.children.length > 1) { // 2nd won't be evaluated if the array is null
					console.log("Mask has multiple members now"); // FIXME deal with order... a little more complex than with shapes____________________________________________
					let onTop = true;
					for (i = selectedShape + 1; i < shapeMasking.length; i++) { // search for shapes in mask that are later in display order
						if (!shapeMasking[i][0] && shapeMasking[i][1] == MASK_NAME) {
							mask.insertBefore(shape, selectedShape[i]);
							onTop = false;
							break;
						}
					}
					if (onTop) { // no shape was found later in display order... this check is to avoid putting the current shape in twice ()
						mask.appendChild(shape);

					}
					
				}
				else {
					mask.appendChild(shape);
				}
				console.log("nwo a child of ", shape.parentNode);
			}
			else if (value == "masked") { 
				console.log("y", shape);
				shape.parentNode.removeChild(shape);
				let onTop = true;
				if (selectedShape < shapes.length - 1) { // if the currently selected shape is NOT the last i.e. NOT to be displayed on top
					console.log("Searching where to slip in");
					for (i = selectedShape + 1; i < shapes.length; i++) { //search for shapes later in display order
						if (shapeMasking[i][0] || shapeMasking[i][1] == "") { // if the later shape is NOT in the mask, insert current shape before it in display order
							console.log("shape", i,"is not In the mask")
							svgObject.insertBefore(shape, shapes[i]);
							onTop = false;
							break;
						}
					}
				}
				if (onTop) { // it's last, add on top of other shapes
					console.log("on top, masked");
					svgObject.appendChild(shape); 
				}
				
				

				maskingOptions[0] = true; //it's gonna be masked by...
				maskingOptions[1] = MASK_NAME; // mask name
				shapes[selectedShape].setAttributeNS(null, "mask", "url(#" + MASK_NAME + ")");
				console.log("Setting mask");
				
			}
			else {//make this a default case too just in case of weird input, but it should be "unmasked" _______________________________
				//check if it was previously sent to mask:

				console.log("y", shape);
				console.log(shape.parentNode);
				shape.setAttributeNS(null, "mask", "");
				shape.parentNode.removeChild(shape);
				let onTop = true;
				if (selectedShape < shapes.length - 1) { // if the currently selected shape is NOT the last i.e. NOT to be displayed on top
					console.log("searching for later shapes");
					for (i = selectedShape + 1; i < shapes.length; i++) { //search for shapes later in display order
						console.log("Shape", i, "is in the mask", shapeMasking[i][0]);
						if (shapeMasking[i][0] || shapeMasking[i][1] == "") { // if the later shape is NOT in the mask, insert current shape before it in display order
							svgObject.insertBefore(shape, shapes[i]);
							onTop = false;
							break;
						}
					}
				}
				if (onTop) { // it's last, add on top of other shapes
					console.log("Shape ", selectedShape, "Top");
					svgObject.appendChild(shape); 
				}
				
				maskingOptions[0] = false;
				maskingOptions[1] = "";
			}

			shapeMasking[selectedShape] = maskingOptions;
			console.log(shapeMasking[selectedShape]);
		}
		function switchRender() {
			console.log(svgObject.getAttribute("shape-rendering"));
			if (svgObject.getAttribute("shape-rendering") == "crispEdges") {
				svgObject.setAttribute("shape-rendering", "geometricPrecision");
			}

			else if (svgObject.getAttribute("shape-rendering") == "geometricPrecision") {
				svgObject.setAttribute("shape-rendering", "crispEdges");
			}
			console.log(svgObject.getAttribute("shape-rendering"));
		}
		xhttp.onreadystatechange = function() {
		    if (this.readyState == 4 && this.status == 200) {
		    	console.log("Going to setup with " + this);
		    	setupSvg(this);
		    }
		};
		function move(amount) {
			if (amount == 0) return;
			var newPos = selectedShape + amount;
			if (newPos > shapes.length - 1) {
				newPos = shapes.length - 1;
			}
			else if (newPos < 0) {
				newPos = 0;
			}
			var increment = amount / Math.abs(amount); //find out which way to move, i.e. increment 1 or -1, in case amount was larger than 1 or less than -1
			console.log(increment);
			for (i = 0; i < (Math.abs(selectedShape - newPos)); i++) { //the selected shape moves along by 1 or -1, swapping with the shape in its target position, till it reaches newPos
				tempShape = shapes[selectedShape];
				tempMasking = shapeMasking[selectedShape];
				shapes[selectedShape] = shapes[selectedShape + increment];
				shapeMasking[selectedShape] = shapeMasking[selectedShape + increment];
				shapes[selectedShape + increment] = tempShape;
				shapeMasking[selectedShape + increment] = tempMasking;
				selectedShape = selectedShape + increment;
			}
			console.log("Position now " + selectedShape);
			console.log("Shape maskgin", shapeMasking[selectedShape][0]);
			let maskingState = "unmasked";
			if (shapeMasking[selectedShape][0]) {
				maskingState = "masked";
			}
			else if (shapeMasking[selectedShape][1] == MASK_NAME) {
				maskingState = "sent";
			}
			console.log("Reinserting shape with state", maskingState);
			masking(maskingState);

		}
		xhttp.open("GET", "svg/iceride.svg", true);
		xhttp.send();
		function copySvgAttr(orig, copy, attr) {
			//console.log(copy, orig, attr);
			copy.setAttributeNS(null, attr, orig.getAttributeNS(null, attr));
		}
		function setupSvg(xml) {
	    	loadedSVG = xml.responseXML.firstChild;

			var loadedElements = loadedSVG.children;
			console.log(loadedElements);
			if (loadedElements.length == 0) {
				console.log("No SVG elements loaded.");
				window.alert("No SVG elements loaded. Stopping script.")
				debugger;
			}
			var j = 0;
			//Messy-----------------------------------------------
			console.log("loade length" + loadedElements.length);
			for (i = 0; i < loadedElements.length; i++) {
				if (loadedElements[i].nodeName == 'defs' | loadedElements[i].nodeName == 'circle' |loadedElements[i].nodeName == 'rect' | loadedElements[i].nodeName == 'line' | loadedElements[i].nodeName == 'path') {

					shapes[j] = loadedElements[i].cloneNode(true);
					let maskingOptions = [];
					maskingOptions[0] = false;
					maskingOptions[1] = "";
					shapeMasking[j] = maskingOptions;
					console.log("loaded" + loadedElements[i].nodeName);
					j++;
				}
			}
			console.log(shapes.length + " shapes loade?");
			svgFrame = document.querySelector(".svg-panel");
			console.log(svgFrame.firstChild);
			svgFrame.removeChild(svgFrame.firstChild);
			svgObject = document.createElementNS("http://www.w3.org/2000/svg", "svg");
			copySvgAttr(loadedSVG, svgObject, "id");
			//copySvgAttr(loadedSVG, svgObject, "xmlns");
			copySvgAttr(loadedSVG, svgObject, "viewBox");
			copySvgAttr(loadedSVG, svgObject, "height");
			copySvgAttr(loadedSVG, svgObject, "width");
			copySvgAttr(loadedSVG, svgObject, "shape-rendering");
			if (!document.querySelector("" + MASK_NAME)) {
				console.log("ADDING MASK");
				//defs go before shapes... of course, this is not compatible with any 
				definitions = document.createElementNS("http://www.w3.org/2000/svg", "defs");
				mask = document.createElementNS("http://www.w3.org/2000/svg", "mask");
				mask.setAttributeNS(null, "id", MASK_NAME);
				/* // First attempted workaround for clipping
				frameRect = document.createElementNS(null, "rect");
				frameRect.setAttributeNS(null, "x", 0);
				frameRect.setAttributeNS(null, "y", 0);
				frameRect.setAttributeNS(null, "width", 500);
				frameRect.setAttributeNS(null, "height", 500);
				frameRect.setAttributeNS(null, "fill", "#ffffff");
				frameRect.setAttributeNS(null, "stroke-width", 1);
				mask.appendChild(frameRect);
				*/
				definitions.appendChild(mask);	
				svgObject.appendChild(definitions);
			}

			//svgFrame.replaceChild(svgObject, svgFrame.firstChild);

			for (i = 0; i < shapes.length; i++) {
				console.log("i is " + i);
				
				svgObject.appendChild(shapes[i])

				console.log("Element copied to final SVG obj");
			}

			document.querySelector("#col-button").value = standardiseColour(shapes[selectedShape].getAttributeNS(null, "stroke"));
			console.log(shapes.length, 'elements loaded!');
			//svgObject = 
			setControls();
			resetHandles(shapes[selectedShape]);

			svgFrame.appendChild(svgObject);	
	    }
	    

		//var svgObject = document.getElementById('vector');
		function downloadSvg() {
			for (i = 0; i < handles.length; i++) {
				svgObject.removeChild(document.querySelector('#handle' + i));
				console.log("removed handles");
			}
			var svgArray = [];
			svgText = '<svg xmlns="http://www.w3.org/2000/svg" id="vector" viewBox="0 0 500 500" height="500" width="500" shape-rendering="crispEdges">';
			svgText += svgObject.innerHTML + '</svg>';
			svgArray[0] = svgText;
			var blob = new Blob(svgArray, {type: 'text/html'});
			var link = document.querySelector('#concealed-dl-link');
			link.style.display = 'inline';
			link.href = URL.createObjectURL(blob);
			link.download = new Date().toLocaleString() + '.svg';
			resetHandles(shapes[selectedShape]);
		}
		function standardiseColour(str){ //Thanks to JayB on SO
		    var ctx = document.createElement("canvas").getContext("2d");
		    ctx.fillStyle = str;
		    return ctx.fillStyle;
		}
		function switchEl(e) {
			for (i = 0; i < handles.length; i++) {
				console.log(i);
				console.log(svgObject);
				console.log(svgObject.querySelector('#handle' + i));
				svgObject.removeChild(svgObject.querySelector('#handle' + i));
			}
			if (selectedShape  < shapes.length - 1) { selectedShape++; } else { selectedShape = 0; }
			document.querySelector("#col-button").value = standardiseColour(shapes[selectedShape].getAttributeNS(null, "stroke"));
			resetHandles(shapes[selectedShape]);
			console.log("Shape no.", selectedShape);
			setControls();
		}
		function changeStrokeWidth(val) {
			shapes[selectedShape].setAttributeNS(null, 'stroke-width', val);
		}
		function changeColour(val) {
			shapes[selectedShape].setAttributeNS(null, 'stroke', val);
		}
		function changeDashArray(val) {
			shapes[selectedShape].setAttributeNS(null, 'stroke-dasharray', val);
		}
		function manifestHandle(x, y) {
			console.log("make");
			var newHandle = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
			newHandle.setAttributeNS(null, 'x', x - handleSize / 2); //handle is around centre point
			newHandle.setAttributeNS(null, 'y', y - handleSize / 2);
			newHandle.setAttributeNS(null, 'width', handleSize);
			newHandle.setAttributeNS(null, 'height', handleSize);
			newHandle.setAttributeNS(null, 'fill', 'red');
			newHandle.setAttributeNS(null, 'class', 'draggable');
			newHandle.setAttributeNS(null, 'id', 'handle' + i);
			newHandle.addEventListener("mousedown", startDragging);
			document.addEventListener("mousemove", drag);
			newHandle.addEventListener("mouseup", endDragging);
			console.log("hwre is it??" + newHandle.getAttributeNS(null, 'id') + x + y);
			svgObject.appendChild(newHandle);
		}
		function getId(handle) {
			return handle.getAttributeNS(null, 'id').charAt(6);
		}
		function startDragging(e) {
			console.log("boom");
			thisHandle = e.currentTarget;
			selectedHandle = getId(thisHandle);
			grabX = e.offsetX - handles[selectedHandle][0];
			grabY = e.offsetY - handles[selectedHandle][1];
			console.log('Graby' + grabX);
			console.log('Graby' + grabY);
			console.log((handles[selectedHandle][0]) + ' ' + (handles[selectedHandle][1])); 
		}
		function drag(e) {
			if (selectedHandle >= 0) { //drawing the lines is making it hard to mouseup
				newX = e.offsetX - grabX;
				newY = e.offsetY - grabY;
				handles[selectedHandle][0] = newX;
				handles[selectedHandle][1] = newY;
				console.log((handles[selectedHandle][0]) + ' ' + (handles[selectedHandle][1])); 
				handle = document.querySelector('#handle' + selectedHandle);
				handle.setAttributeNS(null, 'x', newX - handleSize / 2); //this should be a method that handles it in one place
				handle.setAttributeNS(null, 'y', newY - handleSize / 2);
				time = new Date();
				redrawHandles(); // so they'll be displayed on top - quick and dirty fix
				updateShape(shapes[selectedShape], selectedHandle);
				console.log("Update took", new Date() - time);	//this shows that it's not the function call to UpdateShape that takes time, it's the browser rendering after
			}
		}
		function endDragging(e) {
			selectedHandle = -1;
			dragged = false;

		}
		function redrawHandles() {
			for (i = 0; i < handles.length; i++) {
				handle = svgObject.querySelector('#handle' + i);
				svgObject.removeChild(handle);
				svgObject.appendChild(handle); //quick fix of order of displaying
			}
		}
		function updateShape(shape, handleId) {
			//dragUpdates += 1;
			//console.log("Update " + dragUpdates);
			var stroke = shape.getAttributeNS(null, 'stroke');
			
			if (shape.nodeName == 'line') {
				handleX = handles[handleId][0];
				handleY = handles[handleId][1];
				if (handleId== 0){
				
					shape.setAttributeNS(null, 'x1', handleX);
					shape.setAttributeNS(null, 'y1', handleY);
				}
				else {
					shape.setAttributeNS(null, 'x2',handleX);

					shape.setAttributeNS(null, 'y2', handleY);
				}
			}
			else if (shape.nodeName =='circle') { //leave r for a second
				shape.setAttributeNS(null, 'cx', handles[0][0]);
				shape.setAttributeNS(null, 'cy', handles[0][1]);
			}
			else if (shape.nodeName == 'path') { //FIXME again the assumption that all paths will have data of form M x y q x y x y
				var startX = Number(handles[0][0]);
				var startY = Number(handles[0][1]);
				var data = 'M ' + startX + ' ' + startY + ' q ' + (handles[1][0] - startX) + ' ' + (handles[1][1] - startY) + ' ' + (handles[2][0]- startX) + ' ' + (handles[2][1] - startY);
				console.log(data);
				shape.setAttributeNS(null, 'd', data);

			}
			//shape.setAttributeNS(null, 'stroke-width', 500);
			shape.setAttributeNS(null, 'stroke', stroke);
			//shape.setAttributeNS(null, 'stroke-dasharray', '1,2,1,2,1,1,1,2');
			//shape.setAttributeNS(null, 'mask', 'url(#mask1'); //overall mask for all shapes

			

		}
		function getPathCoords(el) {	// a basic version of what's to come - assume paths only have an M and a q command, in that order
			console.log("getting corods?");
			var data = el.getAttributeNS(null, 'd');
			var parts = [];
			pairs = [];
			parts = data.split(' ');
			if (parts.length > 8 || parts[0] !== 'M' || parts[3] !== 'q') { window.alert('Full data string parsing for path elements not implemented yet!'); debugger; }
			// FIXME MASSIVE ASSUMPTIONS BELOW - implement actual parsing!
			startX = Number(parts[1]);
			startY = Number(parts[2]);
			pairs[0]= [startX, startY];
			handles[0] = [startX, startY];
			pairs[1] = [Number(parts[4]) + startX, Number(parts[5]) + startY];
			pairs[2] = [Number(parts[6]) + startX, Number(parts[7]) + startY];
			
			return pairs;
		}
		function resetHandles(el) { // pass which element you want to handles to control
			console.log("reset, called with " + el.nodeName);
			handles = [];
			
			if (el.nodeName == 'path') {
				handles = getPathCoords(el);
				console.log(handles);
			}
			else if (el.nodeName == 'line') {
				for (i = 0; i < 2; i++) {
					handles.push([el.getAttributeNS(null, 'x' + (i + 1)), el.getAttributeNS(null, 'y' + (i + 1))]);
				}

			}
			else if (el.nodeName =='circle') {
				handles.push([el.getAttributeNS(null, 'cx'), el.getAttributeNS(null, 'cy')]);
			}
			console.log("handles leng" + handles.length);
			for (i = 0; i < handles.length; i++) {
				manifestHandle(handles[i][0], handles[i][1]);
			}
		}
		function setControls() {
			console.log("Switching vals");
			document.querySelector('#dash-array-field').value = shapes[selectedShape].getAttributeNS(null, 'stroke-dasharray');
			document.querySelector('#stroke-width-field').value = shapes[selectedShape].getAttributeNS(null, 'stroke-width');
			if (shapeMasking[selectedShape][0] == true) {
				document.getElementById("masked-button").checked = true;
			}
			else {
				if (shapeMasking[selectedShape][1] != "") {
					document.getElementById("sent-to-mask-button").checked = true;
				}
				else {
					document.getElementById("unmasked-button").checked = true;
				}
				

			}

		}
	</script>
		
</body>