<!DOCTYPE HTML>
<head>
	<meta charset="utf-8">
	<title>Hard-pixel SVG</title>
	<link href="https://fonts.googleapis.com/css?family=Aleo:300&display=swap" rel="stylesheet" />
	<link rel="stylesheet" href="css/styles.css" type="text/css" />
	<style></style>
</head>
<body>
	<header>
		<h1>Hard-pixel SVG: Masked Moir√©</h1>
		<h3>by Kevin Higgins</h3>
	</header>
	<main class="main-block">
		<a id="concealed-dl-link">Download SVG</a> <!--technique from boomcreeper11 on SO-->
		<div class="panels">
			<div class="svg-panel"><svg></svg>
			</div>
			<div class="control-panel">
				<h4>Edit selected shape</h4><label for="dash-array-field">Stroke dash array</label>
				<input type="text" value="1,1" id="dash-array-field" /><label for="stroke-width-field">Stroke width</label><input type="number" placeholder="1" max="500" min="0" value="40" id="stroke-width-field" />
				<hr />

				<input type="button" value="Next path" id="reset-button"></input>
				<input type="button" value="Download" id="dl-button"></input>
				<input type="color" value="#ffffff" id="col-button"></input>
			</div>
			
		</div>
	</main>
	<script>
		document.querySelector('#reset-button').addEventListener("click", switchEl);
		document.querySelector('#dl-button').addEventListener("click", downloadSvg);
		document.querySelector('#dash-array-field').addEventListener("input", function() { changeDashArray(this.value) });
		document.querySelector('#stroke-width-field').addEventListener("change", function() { changeStrokeWidth(this.value) });
		document.querySelector('#col-button').addEventListener("change", function() { changeColour(this.value) });
		var xhttp = new XMLHttpRequest();
		var handleSize = 10;

		var handles = [];
		var shapes = []; //conceptually inconsistently, this will hold actual line elements (until we generalise to shapes) rather than, as handles does, coords for elements
		var selectedHandle = -1;
		var selectedShape = 0; // there'll always be a shapes selected; start with first member of array selected
		var svgObject;
		xhttp.onreadystatechange = function() {
		    if (this.readyState == 4 && this.status == 200) {
		    	console.log("Going to setup with " + this);
		    	setupSvg(this);
		    }
		};
		xhttp.open("GET", "blend.svg", true);
		xhttp.send();
		function setupSvg(xml) {
	    	svgObject = xml.responseXML.firstChild;

			var loadedElements = svgObject.children;
			console.log(loadedElements);
			if (loadedElements.length == 0) {
				console.log("No SVG elements loaded.");
				window.alert("No SVG elements loaded. Stopping script.")
				debugger;
			}
			var j = 0;
			for (i = 0; i < loadedElements.length; i++) {
				if (loadedElements[i].nodeName == 'circle' |loadedElements[i].nodeName == 'rect' | loadedElements[i].nodeName == 'line' | loadedElements[i].nodeName == 'path') {
					shapes[j] = loadedElements[i];
					j++;
				}
			}
			svgFrame = document.querySelector(".svg-panel");
			console.log(svgFrame.firstChild);
			svgFrame.replaceChild(svgObject, svgFrame.firstChild);
			document.querySelector("#col-button").value = standardiseColour(shapes[selectedShape].getAttributeNS(null, "stroke"));
			console.log(shapes.length, 'elements loaded!');
			setControls();
			resetHandles(shapes[selectedShape]);
	    }
	    

		//var svgObject = document.getElementById('vector');
		function downloadSvg() {
			for (i = 0; i < handles.length; i++) {
				svgObject.removeChild(document.querySelector('#handle' + i));
			}
			var svgArray = [];
			svgText = '<svg xmlns="http://www.w3.org/2000/svg" id="vector" viewBox="0 0 500 500" height="500" width="500" shape-rendering="crispEdges">';
			svgText += svgObject.innerHTML + '</svg>';
			svgArray[0] = svgText;
			var blob = new Blob(svgArray, {type: 'text/html'});
			var link = document.querySelector('#concealed-dl-link');
			link.style.display = 'inline';
			link.href = URL.createObjectURL(blob);
			link.download = new Date().toLocaleString() + '.svg';
			resetHandles(shapes[selectedShape]);
		}
		function standardiseColour(str){ //Thanks to JayB on SO
		    var ctx = document.createElement("canvas").getContext("2d");
		    ctx.fillStyle = str;
		    return ctx.fillStyle;
		}
		function switchEl(e) {
			for (i = 0; i < handles.length; i++) {
				svgObject.removeChild(document.querySelector('#handle' + i));
			}
			if (selectedShape  < shapes.length - 1) { selectedShape++; } else { selectedShape = 0; }
			document.querySelector("#col-button").value = standardiseColour(shapes[selectedShape].getAttributeNS(null, "stroke"));
			resetHandles(shapes[selectedShape]);
			console.log("Shape no.", selectedShape);
			setControls();
		}
		function changeStrokeWidth(val) {
			shapes[selectedShape].setAttributeNS(null, 'stroke-width', val);
		}
		function changeColour(val) {
			shapes[selectedShape].setAttributeNS(null, 'stroke', val);
		}
		function changeDashArray(val) {
			shapes[selectedShape].setAttributeNS(null, 'stroke-dasharray', val);
		}
		function manifestHandle(x, y) {
			console.log("make");
			var newHandle = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
			newHandle.setAttributeNS(null, 'x', x - handleSize / 2); //handle is around centre point
			newHandle.setAttributeNS(null, 'y', y - handleSize / 2);
			newHandle.setAttributeNS(null, 'width', handleSize);
			newHandle.setAttributeNS(null, 'height', handleSize);
			newHandle.setAttributeNS(null, 'fill', 'red');
			newHandle.setAttributeNS(null, 'class', 'draggable');
			newHandle.setAttributeNS(null, 'id', 'handle' + i);
			newHandle.addEventListener("mousedown", startDragging);
			document.addEventListener("mousemove", drag);
			newHandle.addEventListener("mouseup", endDragging);
			svgObject.appendChild(newHandle);
		}
		function getId(handle) {
			return handle.getAttributeNS(null, 'id').charAt(6);
		}
		function startDragging(e) {
			thisHandle = e.currentTarget;
			selectedHandle = getId(thisHandle);
			grabX = e.offsetX - handles[selectedHandle][0];
			grabY = e.offsetY - handles[selectedHandle][1];
			console.log('Graby' + grabX);
			console.log('Graby' + grabY);
			console.log((handles[selectedHandle][0]) + ' ' + (handles[selectedHandle][1])); 
		}
		function drag(e) {
			if (selectedHandle >= 0) { //drawing the lines is making it hard to mouseup
				newX = e.offsetX - grabX;
				newY = e.offsetY - grabY;
				handles[selectedHandle][0] = newX;
				handles[selectedHandle][1] = newY;
				console.log((handles[selectedHandle][0]) + ' ' + (handles[selectedHandle][1])); 
				handle = document.querySelector('#handle' + selectedHandle);
				handle.setAttributeNS(null, 'x', newX - handleSize / 2); //this should be a method that handles it in one place
				handle.setAttributeNS(null, 'y', newY - handleSize / 2);
				updateShape(shapes[selectedShape], selectedHandle); // on the way to generalising it
				redrawHandles(); // so they'll be displayed on top - quick and dirty fix
			}
		}
		function endDragging(e) {
			selectedHandle = -1;

		}
		function redrawHandles() {
			for (i = 0; i < handles.length; i++) {
				handle = document.querySelector('#handle' + i);
				svgObject.removeChild(handle);
				svgObject.appendChild(handle); //quick fix of order of displaying
			}
		}
		function updateShape(shape, handleId) {
			var stroke = shape.getAttributeNS(null, 'stroke');
			//svgObject.removeChild(shape);
			if (shape.nodeName == 'line') {
				handleX = handles[handleId][0];
				handleY = handles[handleId][1];
				if (handleId== 0){
				
					shape.setAttributeNS(null, 'x1', handleX);
					shape.setAttributeNS(null, 'y1', handleY);
				}
				else {
					shape.setAttributeNS(null, 'x2',handleX);

					shape.setAttributeNS(null, 'y2', handleY);
				}
			}
			else if (shape.nodeName =='circle') { //leave r for a second
				shape.setAttributeNS(null, 'cx', handles[0][0]);
				shape.setAttributeNS(null, 'cy', handles[0][1]);
			}
			else if (shape.nodeName == 'path') { //FIXME again the assumption that all paths will have data of form M x y q x y x y
				var startX = Number(handles[0][0]);
				var startY = Number(handles[0][1]);
				var data = 'M ' + startX + ' ' + startY + ' q ' + (handles[1][0] - startX) + ' ' + (handles[1][1] - startY) + ' ' + (handles[2][0]- startX) + ' ' + (handles[2][1] - startY);
				console.log(data);
				shape.setAttributeNS(null, 'd', data);

			}
			//shape.setAttributeNS(null, 'stroke-width', 500);
			shape.setAttributeNS(null, 'stroke', stroke);
			//shape.setAttributeNS(null, 'stroke-dasharray', '1,2,1,2,1,1,1,2');
			//shape.setAttributeNS(null, 'mask', 'url(#mask1'); //overall mask for all shapes
			//svgObject.appendChild(shape);

		}
		function getPathCoords(el) {	// a basic version of what's to come - assume paths only have an M and a q command, in that order
			var data = el.getAttributeNS(null, 'd');
			var parts = [];
			pairs = [];
			parts = data.split(' ');
			if (parts.length > 8 || parts[0] !== 'M' || parts[3] !== 'q') { window.alert('Full data string parsing for path elements not implemented yet!'); debugger; }
			// FIXME MASSIVE ASSUMPTIONS BELOW - implement actual parsing!
			startX = Number(parts[1]);
			startY = Number(parts[2]);
			pairs[0]= [startX, startY];
			handles[0] = [startX, startY];
			pairs[1] = [Number(parts[4]) + startX, Number(parts[5]) + startY];
			pairs[2] = [Number(parts[6]) + startX, Number(parts[7]) + startY];
			return pairs;
		}
		function resetHandles(el) { // pass which element you want to handles to control
			console.log("reset");
			handles = [];
			
			if (el.nodeName == 'path') {
				handles = getPathCoords(el);
			}
			else if (el.nodeName == 'line') {
				for (i = 0; i < 2; i++) {
					handles.push([el.getAttributeNS(null, 'x' + (i + 1)), el.getAttributeNS(null, 'y' + (i + 1))]);
				}

			}
			else if (el.nodeName =='circle') {
				handles.push([el.getAttributeNS(null, 'cx'), el.getAttributeNS(null, 'cy')]);
			}
			for (i = 0; i < handles.length; i++) {
				manifestHandle(handles[i][0], handles[i][1]);
			}
		}
		function setControls() {
			console.log("Switching vals");
			document.querySelector('#dash-array-field').value = shapes[selectedShape].getAttributeNS(null, 'stroke-dasharray');
			document.querySelector('#stroke-width-field').value = shapes[selectedShape].getAttributeNS(null, 'stroke-width');
		}
	
		
	</script>
		
</body>